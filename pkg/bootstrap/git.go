package bootstrap

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/go-github/v43/github"
	"sigs.k8s.io/yaml"
)

func (b *Bootstrapper) buildCommitEntries() ([]*github.TreeEntry, error) {
	var entries []*github.TreeEntry

	{
		filePath := fmt.Sprintf("%s/cluster.yaml", b.managementClusterName)
		clusterDefinition := ClusterDefinition{
			Base:            b.baseDomain,
			Codename:        b.managementClusterName,
			Customer:        b.customer,
			AccountEngineer: b.accountEngineer,
			Pipeline:        b.pipeline,
			Provider:        b.provider,
		}
		content, err := yaml.Marshal(clusterDefinition)
		if err != nil {
			return nil, err
		}
		entries = append(entries, &github.TreeEntry{
			Path:    github.String(filePath),
			Type:    github.String("blob"),
			Content: github.String(string(content)),
			Mode:    github.String("100644"),
		})
	}

	appCatalogValues := AppCatalogValues{
		AppCatalog: AppCatalog{
			Config: AppCatalogConfig{
				ConfigMap: AppCatalogConfigConfigMap{
					Values: AppCatalogConfigConfigMapValues{
						BaseDomain:        b.baseDomain,
						ManagementCluster: b.managementClusterName,
						Provider:          b.provider,
					},
				},
			},
		},
	}
	appCatalogValuesYAML, err := yaml.Marshal(appCatalogValues)
	if err != nil {
		return nil, err
	}

	for _, catalog := range []string{"cluster", "cluster-test", "default", "default-test"} {
		filePath := fmt.Sprintf("%s/appcatalog/%s-appcatalog-values.yaml", b.managementClusterName, catalog)
		entries = append(entries, &github.TreeEntry{
			Path:    github.String(filePath),
			Type:    github.String("blob"),
			Content: github.String(string(appCatalogValuesYAML)),
			Mode:    github.String("100644"),
		})
	}

	return entries, nil
}

// getRef returns the commit branch reference object if it exists or creates it
// from the base branch before returning it.
func (b *Bootstrapper) getRef(ctx context.Context, branchName string) (ref *github.Reference, err error) {
	ref, _, err = b.gitHubClient.Git.GetRef(ctx, "giantswarm", "installations", "refs/heads/"+branchName)
	if err == nil {
		return ref, nil
	}

	baseRef, _, err := b.gitHubClient.Git.GetRef(ctx, "giantswarm", "installations", "refs/heads/master")
	if err != nil {
		return nil, err
	}

	newRef := github.Reference{
		Ref:    github.String("refs/heads/" + branchName),
		Object: &github.GitObject{SHA: baseRef.Object.SHA},
	}
	ref, _, err = b.gitHubClient.Git.CreateRef(ctx, "giantswarm", "installations", &newRef)
	return ref, err
}

// pushCommit creates the commit in the given reference using the given tree.
func (b *Bootstrapper) pushCommit(ctx context.Context, ref *github.Reference, tree *github.Tree) (err error) {
	// Get the parent commit to attach the commit to.
	parent, _, err := b.gitHubClient.Repositories.GetCommit(ctx, "giantswarm", "installations", *ref.Object.SHA, nil)
	if err != nil {
		return err
	}

	// This is not always populated, but is needed.
	parent.Commit.SHA = parent.SHA

	// Create the commit using the tree.
	date := time.Now()
	author := &github.CommitAuthor{
		Date:  &date,
		Name:  github.String("capi-bootstrap"),
		Email: github.String("capi-bootstrap@giantswarm.io"),
	}
	commit := &github.Commit{
		Author:  author,
		Message: github.String("bootstrap " + b.managementClusterName),
		Tree:    tree,
		Parents: []*github.Commit{parent.Commit},
	}
	newCommit, _, err := b.gitHubClient.Git.CreateCommit(ctx, "giantswarm", "installations", commit)
	if err != nil {
		return err
	}

	// Attach the commit to the master branch.
	ref.Object.SHA = newCommit.SHA
	_, _, err = b.gitHubClient.Git.UpdateRef(ctx, "giantswarm", "installations", ref, false)
	return err
}

func (b *Bootstrapper) createInstallationsBranch(ctx context.Context, branchName string) error {
	branchRef, err := b.getRef(ctx, branchName)
	if err != nil {
		return err
	}

	entries, err := b.buildCommitEntries()
	if err != nil {
		return err
	}

	tree, _, err := b.gitHubClient.Git.CreateTree(ctx, "giantswarm", "installations", *branchRef.Object.SHA, entries)
	if err != nil {
		return err
	}

	if err := b.pushCommit(ctx, branchRef, tree); err != nil {
		return err
	}

	newPR := github.NewPullRequest{
		Title:               github.String("Bootstrap " + b.managementClusterName),
		Head:                github.String(branchName),
		Base:                github.String("master"),
		Body:                github.String("PR generated by capi-bootstrap"),
		MaintainerCanModify: github.Bool(true),
	}
	_, _, err = b.gitHubClient.PullRequests.Create(ctx, "giantswarm", "installations", &newPR)
	if ghErr, ok := err.(*github.ErrorResponse); ok {
		if len(ghErr.Errors) == 1 && strings.HasPrefix(ghErr.Errors[0].Message, "A pull request already exists for") {
			return nil
		}
	}

	return err
}
